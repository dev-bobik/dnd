
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DnD Battle Grid</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      flex-direction: row;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a0a0a 50%, #0a0a0a 100%);
      background-attachment: fixed;
      color: white;
      min-height: 100vh;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(ellipse at 20% 30%, rgba(138, 43, 226, 0.15) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 70%, rgba(30, 144, 255, 0.1) 0%, transparent 50%);
      pointer-events: none;
      z-index: 0;
    }

    body::after {
      content: 'üêâ';
      position: fixed;
      font-size: 600px;
      opacity: 0.02;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(-15deg);
      pointer-events: none;
      z-index: 0;
    }

    #sidebar {
      width: 200px;
      background: rgba(20, 20, 20, 0.8);
      backdrop-filter: blur(10px);
      border-right: 2px solid rgba(138, 43, 226, 0.3);
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      overflow-y: auto;
      position: relative;
      z-index: 1;
      box-shadow: 5px 0 30px rgba(0, 0, 0, 0.5);
    }

    #sidebar h3 {
      color: #8A2BE2;
      font-size: 1.3rem;
      font-weight: 600;
      text-align: center;
      margin: 0 0 1rem 0;
      text-shadow: 0 0 10px rgba(138, 43, 226, 0.5);
    }

    .library-token {
      width: 50px;
      height: 50px;
      cursor: grab;
      border: 2px solid rgba(138, 43, 226, 0.5);
      border-radius: 8px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .library-token:hover {
      transform: scale(1.1);
      border-color: #8A2BE2;
      box-shadow: 0 5px 20px rgba(138, 43, 226, 0.6);
    }

    .category {
      margin-bottom: 0.5rem;
    }

    .category-header {
      color: #8A2BE2;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 6px;
      transition: all 0.3s ease;
      user-select: none;
    }

    .category-header:hover {
      background: rgba(138, 43, 226, 0.2);
    }

    .category-header span {
      display: inline-block;
      transition: transform 0.3s ease;
      margin-right: 0.5rem;
    }

    .category-header.open span {
      transform: rotate(90deg);
    }

    .category-content {
      padding-left: 1rem;
      padding-top: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem;
      padding-bottom: 3rem;
      position: relative;
      z-index: 1;
      overflow-y: auto;
    }

    #main h1 {
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #8A2BE2, #1E90FF);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin: 0 0 1rem 0;
      text-shadow: 0 0 30px rgba(138, 43, 226, 0.5);
    }

    #controls {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
      background: rgba(20, 20, 20, 0.6);
      backdrop-filter: blur(10px);
      padding: 1rem;
      border-radius: 12px;
      border: 1px solid rgba(138, 43, 226, 0.3);
      flex-wrap: wrap;
      justify-content: center;
    }

    #controls label {
      color: #ccc;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    #controls select,
    #controls input[type="file"],
    #controls input[type="color"],
    #controls input[type="range"] {
      background: rgba(30, 30, 30, 0.8);
      border: 1px solid rgba(138, 43, 226, 0.4);
      color: white;
      padding: 0.4rem;
      border-radius: 6px;
    }

    #controls button {
      background: linear-gradient(135deg, #8A2BE2, #1E90FF);
      border: none;
      color: white;
      padding: 0.6rem 1.2rem;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
    }

    #controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(138, 43, 226, 0.6);
    }

    #deleteAllTokensBtn {
      background: linear-gradient(135deg, #b33, #d44) !important;
      box-shadow: 0 4px 15px rgba(187, 51, 51, 0.4) !important;
    }

    #deleteAllTokensBtn:hover {
      box-shadow: 0 6px 20px rgba(187, 51, 51, 0.6) !important;
    }

    #grid-container {
      position: relative;
      aspect-ratio: 1 / 1;
      width: 1200px;
      max-width: 90vw;
      margin-bottom: 2rem;
      transition: aspect-ratio 0.3s ease;
    }

    #background {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #grid {
      display: grid;
      gap: 1px;
      background-color: transparent;
      border: 2px solid rgba(138, 43, 226, 0.5);
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      width: 100%;
      height: 100%;
      box-shadow: 0 0 30px rgba(138, 43, 226, 0.3);
      pointer-events: none;
    }
    
    #grid.visible {
      pointer-events: auto;
    }

    .cell {
      background-color: transparent; 
      border: 1px solid rgba(0, 0, 0, 0.8); 
      position: relative;
      aspect-ratio: 1 / 1;
    }

    #tokens-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
    }

    .token {
      position: absolute;
      cursor: grab;
      filter: drop-shadow(0 4px 10px rgba(0, 0, 0, 0.6)) drop-shadow(0 0 8px rgba(138, 43, 226, 0.3));
      transition: all 0.2s ease;
      pointer-events: auto;
    }

    .token:hover {
      filter: drop-shadow(0 6px 15px rgba(0, 0, 0, 0.8)) drop-shadow(0 0 15px rgba(138, 43, 226, 0.6));
      transform: scale(1.05);
    }

    .token:active {
      cursor: grabbing;
    }

    #drawLayer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 3; /* nad tokeny */
      touch-action: none; /* zabr√°n√≠ implicitn√≠m posun≈Øm p≈ôi kreslen√≠ na dotykov√Ωch za≈ô√≠zen√≠ch */
      pointer-events: none; /* defaultnƒõ zak√°zat klik√°n√≠, zapneme v draw m√≥du */
    }  


    input[type="file"], select {
      margin: 0.5rem 0;
    }
  </style>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyCIZjiTltMTVktH4qTuW4iclUqFwuIbU9E",
      authDomain: "heil-47dc3.firebaseapp.com",
      databaseURL: "https://heil-47dc3-default-rtdb.firebaseio.com",
      projectId: "heil-47dc3",
      storageBucket: "heil-47dc3.appspot.com",
      messagingSenderId: "204548727050",
      appId: "1:204548727050:web:14066e11908a1fd97f9af3",
      measurementId: "G-TJZZDNCV05"
    };
    firebase.initializeApp(firebaseConfig);
    var db = firebase.database();
    var auth = firebase.auth();
  </script>
</head>
<body>
  <div id="sidebar">
    <h3>Knihovna</h3>
    
    <div class="category">
      <div class="category-header" onclick="toggleCategory(this)">
        <span>‚ñ∂</span> Characters
      </div>
      <div class="category-content" style="display: none;">
        <img src="https://i.redd.it/axxsavk41ot21.jpg" class="library-token" draggable="true">
        <img src="https://media.discordapp.net/attachments/1328441040730062951/1438654654102900799/image.png?ex=691eeb4e&is=691d99ce&hm=85344af798a39fa464110c7196f13d2696596f07e605e44157a482d66901dced&=&format=webp&quality=lossless&width=886&height=930" class="library-token" draggable="true">
        <img src="https://cdn.discordapp.com/attachments/1328441040730062951/1438606380553736334/image.png?ex=691ebe59&is=691d6cd9&hm=a2227a7ff2fde46d0f444bf00b1ed896df7b315f3917a20c960846f10e270b62&" class="library-token" draggable="true">
        <img src="https://cdn.discordapp.com/attachments/1328441040730062951/1433534878124867704/rhae.webp?ex=691ec024&is=691d6ea4&hm=29ddfbfd8a8078afbe0b18883758cf6466fd93bd09e5580c67cea86e0f2bcc76&" class="library-token" draggable="true">
        <img src="https://cdn.discordapp.com/attachments/1328441040730062951/1433534352796684308/image.png?ex=691ebfa7&is=691d6e27&hm=511d11cfa6a779440ccdfacda239c1ff7f2af4ad10722e573b28aca274bcf55e&" class="library-token" draggable="true">
      </div>
    </div>

    <div class="category">
      <div class="category-header" onclick="toggleCategory(this)">
        <span>‚ñ∂</span> Objects
      </div>
      <div class="category-content" style="display: none;">
      </div>
    </div>

    <div class="category">
      <div class="category-header" onclick="toggleCategory(this)">
        <span>‚ñ∂</span> Items
      </div>
      <div class="category-content" style="display: none;">
      </div>
    </div>

    <div class="category">
      <div class="category-header" onclick="toggleCategory(this)">
        <span>‚ñ∂</span> Enemies
      </div>
      <div class="category-content" style="display: none;">
      </div>
    </div>

    <div class="category">
      <div class="category-header" onclick="toggleCategory(this)">
        <span>‚ñ∂</span> Others
      </div>
      <div class="category-content" style="display: none;">
      </div>
    </div>

     <button id="deleteAllTokensBtn" style="margin-top: auto; background:#b33; color:#fff; border:none; padding:0.5rem; border-radius:4px; cursor:pointer;">
  Smazat v≈°echny tokeny
</button>
  </div>
  <div id="main">
    <h1>DnD Fight Grid</h1>
    <div id="controls">
      <label>Nahr√°t tokeny: <input type="file" id="upload" accept="image/*" /></label>
      <label>Nahr√°t pozad√≠: <input type="file" id="backgroundUpload" accept="image/*" /></label>
      <label>Velikost pol√≠:
        <select id="cellSizeSelect">
          <option value="20">Minim√°ln√≠ (20px)</option>
          <option value="40">Mal√° (40px)</option>
          <option value="60" selected>St≈ôedn√≠ (60px)</option>
          <option value="80">Velk√° (80px)</option>
          <option value="100">Maxim√°ln√≠ (100px)</option>
        </select>
      </label>
      <label><input type="checkbox" id="gridToggle" checked> Zobrazit m≈ô√≠≈æku</label>
      <label>Pomƒõr stran:
        <select id="aspectRatioSelect">
          <option value="1/1" selected>ƒåtverec (1:1)</option>
          <option value="16/9">Obdeln√≠k 16:9</option>
          <option value="4/3">Obdeln√≠k 4:3</option>
          <option value="3/2">Obdeln√≠k 3:2</option>
          <option value="2/1">≈†irok√Ω 2:1</option>
        </select>
      </label>
      <label>Velikost token≈Ø:
        <select id="tokenSizeSelect">
          <option value="0.5">Mal√© (0.5x)</option>
          <option value="1" selected>Norm√°ln√≠ (1x)</option>
          <option value="1.5">Vƒõt≈°√≠ (1.5x)</option>
          <option value="2">Velk√© (2x)</option>
          <option value="3">Obrovsk√© (3x)</option>
        </select>
      </label>
    </div>
    <div id="controls">
      <label>Barva kreslen√≠: <input type="color" id="drawColor" value="#ff0000"></label>
      <label>≈†√≠≈ôka pera: 
        <input type="range" id="brushWidth" min="1" max="50" value="2" step="1">
        <span id="brushWidthValue">2</span>px
      </label>
      <button id="toggleDraw">Re≈æim kreslen√≠</button>
      <button id="undoDraw">Zpƒõt (posledn√≠ kresba)</button>
      <button id="clearCanvas">Smazat kresby</button>
    </div>

    <div id="grid-container">
      <img id="background" />
      <canvas id="drawLayer"></canvas>
      <div id="grid"></div>
      <div id="tokens-container"></div>
    </div>
  </div>
    <script>
const grid = document.getElementById('grid');
const gridContainer = document.getElementById('grid-container');
const cellSizeSelect = document.getElementById('cellSizeSelect');
let cellSize = parseInt(cellSizeSelect.value);

function createGrid() {
  grid.innerHTML = '';
  
  // Z√≠skej aktu√°ln√≠ aspect ratio
  const aspectRatioStr = gridContainer.style.aspectRatio || '1 / 1';
  const [width, height] = aspectRatioStr.split('/').map(s => parseFloat(s.trim()));
  
  const containerWidth = gridContainer.clientWidth;
  const containerHeight = gridContainer.clientHeight;
  
  // Poƒçet pol√≠ƒçek podle pomƒõru stran - cellSize urƒçuje, kolik se jich vejde
  // Spoƒç√≠tej tak, aby ƒçtverce mƒõly p≈ôibli≈ænƒõ velikost cellSize
  const columns = Math.round(containerWidth / cellSize);
  const rows = Math.round(columns * (height / width)); // Zachovej pomƒõr stran

  // ƒåtvercov√© bu≈àky
  grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
  grid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

  for (let i = 0; i < columns * rows; i++) {
    const cell = document.createElement('div');
    cell.classList.add('cell');
    grid.appendChild(cell);
  }
}

cellSizeSelect.addEventListener('change', () => {
  const newCellSize = parseInt(cellSizeSelect.value);
  const scale = newCellSize / cellSize;
  cellSize = newCellSize;
  createGrid();

  document.querySelectorAll('.token').forEach(token => {
    const newLeft = parseFloat(token.style.left) * scale;
    const newTop = parseFloat(token.style.top) * scale;
    token.style.width = `${cellSize}px`;
    token.style.height = `${cellSize}px`;
    token.style.left = `${newLeft}px`;
    token.style.top = `${newTop}px`;

    const tokenId = Object.entries(db._root._value.tokens || {}).find(([_, t]) => t.src === token.src)?.[0];
    if (tokenId) {
      db.ref('tokens/' + tokenId).update({
        top: newTop,
        left: newLeft,
        width: cellSize,
        height: cellSize
      });
    }
  });
});

// Grid toggle
const gridToggle = document.getElementById('gridToggle');
gridToggle.addEventListener('change', (e) => {
  const isVisible = e.target.checked;
  const grid = document.getElementById('grid');
  if (isVisible) {
    grid.style.display = 'grid';
    grid.classList.add('visible');
  } else {
    grid.style.display = 'none';
    grid.classList.remove('visible');
  }
  // Synchronizuj s Firebase
  db.ref('settings/gridVisible').set(isVisible);
});

// Token size
let tokenSizeMultiplier = 1;
const tokenSizeSelect = document.getElementById('tokenSizeSelect');
tokenSizeSelect.addEventListener('change', (e) => {
  tokenSizeMultiplier = parseFloat(e.target.value);
  
  // Pouze synchronizuj nastaven√≠ do Firebase
  // Nemƒõ≈à existuj√≠c√≠ tokeny - velikost se pou≈æije jen pro nov√© tokeny
  db.ref('settings/tokenSizeMultiplier').set(tokenSizeMultiplier);
});

// Aspect ratio
const aspectRatioSelect = document.getElementById('aspectRatioSelect');
aspectRatioSelect.addEventListener('change', (e) => {
  const aspectRatio = e.target.value;
  const gridContainer = document.getElementById('grid-container');
  gridContainer.style.aspectRatio = aspectRatio;
  createGrid();
  setTimeout(resizeCanvas, 100);
  // Synchronizuj s Firebase
  db.ref('settings/aspectRatio').set(aspectRatio);
});

// Synchronizace nastaven√≠ z Firebase
db.ref('settings/gridVisible').on('value', (snapshot) => {
  const isVisible = snapshot.val();
  if (isVisible !== null) {
    gridToggle.checked = isVisible;
    const grid = document.getElementById('grid');
    grid.style.display = isVisible ? 'grid' : 'none';
    if (isVisible) {
      grid.classList.add('visible');
    } else {
      grid.classList.remove('visible');
    }
  }
});

db.ref('settings/tokenSizeMultiplier').on('value', (snapshot) => {
  const multiplier = snapshot.val();
  if (multiplier !== null) {
    tokenSizeMultiplier = multiplier;
    tokenSizeSelect.value = multiplier.toString();
  }
});

db.ref('settings/aspectRatio').on('value', (snapshot) => {
  const aspectRatio = snapshot.val();
  if (aspectRatio) {
    aspectRatioSelect.value = aspectRatio;
    const gridContainer = document.getElementById('grid-container');
    gridContainer.style.aspectRatio = aspectRatio;
    createGrid();
    setTimeout(resizeCanvas, 100);
  }
});

createGrid();

const upload = document.getElementById('upload');

upload.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function (event) {
    const id = Date.now();
    const tokenData = {
      id,
      src: event.target.result,
      top: 0,
      left: 0,
      width: cellSize,
      height: cellSize
    };
    db.ref('tokens/' + id).set(tokenData);
  };

  reader.readAsDataURL(file);
  e.target.value = "";
});


    const backgroundInput = document.getElementById('backgroundUpload');
    const background = document.getElementById('background');

    const tokensContainer = document.getElementById('tokens-container');

    function startRealtimeSync() {
      db.ref('tokens').on('value', (snapshot) => {
        const tokens = snapshot.val() || {};
        document.querySelectorAll('.token').forEach(el => el.remove());
        for (let key in tokens) {
          const data = tokens[key];
          const img = document.createElement('img');
          img.src = data.src;
          img.classList.add('token');
          img.draggable = true;
          img.style.top = `${data.top}px`;
          img.style.left = `${data.left}px`;
          img.style.width = `${data.width}px`;
          img.style.height = `${data.height}px`;

          let offsetX, offsetY;

          img.addEventListener('dragstart', (e) => {
            offsetX = e.offsetX;
            offsetY = e.offsetY;
            e.dataTransfer.setData('tokenId', data.id);
          });

          img.addEventListener('dragend', (e) => {
            const rect = tokensContainer.getBoundingClientRect();
            const newLeft = e.clientX - rect.left - offsetX;
            const newTop = e.clientY - rect.top - offsetY;
            db.ref('tokens/' + data.id).update({ left: newLeft, top: newTop });
          });

          tokensContainer.appendChild(img);
        }
      });

      db.ref('background').on('value', (snapshot) => {
        if (snapshot.val()) {
          background.src = snapshot.val();
        }
      });

      backgroundInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (event) {
          const imageUrl = event.target.result;
          const img = new Image();
          img.onload = function() {
            // Automaticky nastav pomƒõr stran podle obr√°zku
            const aspectRatio = img.width / img.height;
            gridContainer.style.aspectRatio = `${img.width} / ${img.height}`;
            
            // Aktualizuj select s pomƒõrem stran
            const aspectRatioSelect = document.getElementById('aspectRatioSelect');
            let matchFound = false;
            
            // Zkontroluj, jestli odpov√≠d√° nƒõjak√©mu preset pomƒõru
            const presets = {
              '1/1': 1,
              '16/9': 16/9,
              '4/3': 4/3,
              '3/2': 3/2,
              '2/1': 2
            };
            
            for (let [key, value] of Object.entries(presets)) {
              if (Math.abs(aspectRatio - value) < 0.1) {
                aspectRatioSelect.value = key;
                matchFound = true;
                break;
              }
            }
            
            if (!matchFound) {
              // P≈ôidej custom option
              const customOption = document.createElement('option');
              customOption.value = `${img.width}/${img.height}`;
              customOption.text = `Vlastn√≠ (${img.width}:${img.height})`;
              customOption.selected = true;
              aspectRatioSelect.appendChild(customOption);
            }
            
            // Synchronizuj aspect ratio do Firebase
            db.ref('settings/aspectRatio').set(aspectRatioSelect.value);
            
            createGrid();
            setTimeout(resizeCanvas, 100);
          };
          img.src = imageUrl;
          background.src = imageUrl;
          db.ref('background').set(imageUrl);
        };

        reader.readAsDataURL(file);
        e.target.value = "";
      });

      // Kreslen√≠ - naƒç√≠tej strokes z datab√°ze
      db.ref('drawing').on('child_added', (snapshot) => {
        const stroke = snapshot.val();
        const timestamp = snapshot.key;
        if (stroke && stroke.points) {
          drawStroke(stroke);
          // P≈ôidej timestamp do historie, pokud tam je≈°tƒõ nen√≠
          if (!drawingHistory.includes(timestamp)) {
            drawingHistory.push(timestamp);
          }
        }
      });

      db.ref('drawing').on('value', (snapshot) => {
        if (!snapshot.val()) {
          ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
          drawingHistory = [];
        }
      });

      // Biblioteka tokeny
      document.querySelectorAll('.library-token').forEach(token => {
        token.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('src', token.src);
        });
      });

      // Grid dragover a drop
      tokensContainer.addEventListener('dragover', (e) => e.preventDefault());
      tokensContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        const rect = tokensContainer.getBoundingClientRect();
        const tokenId = e.dataTransfer.getData('tokenId'); 
        const src = e.dataTransfer.getData('src');          

        if (tokenId) {
          const newLeft = e.clientX - rect.left;
          const newTop = e.clientY - rect.top;
          db.ref('tokens/' + tokenId).update({
            left: newLeft,
            top: newTop
          });
        } else if (src) {
          const id = Date.now();
          db.ref('tokens/' + id).set({
            id,
            src,
            top: e.clientY - rect.top,
            left: e.clientX - rect.left,
            width: cellSize * tokenSizeMultiplier,
            height: cellSize * tokenSizeMultiplier
          });
        }
      });
    }

    firebase.auth().signInAnonymously()
      .then(() => {
        console.log("‚úÖ P≈ôihl√°≈°en anonymnƒõ");
        startRealtimeSync();
      })
      .catch((error) => {
        console.error("‚ùå Chyba p≈ôihl√°≈°en√≠:", error);
      });

    const deleteAllTokensBtn = document.getElementById('deleteAllTokensBtn');

deleteAllTokensBtn.addEventListener('click', () => {
  if (confirm('Opravdu chcete smazat v≈°echny tokeny z m≈ô√≠≈æky?')) {
    db.ref('tokens').remove()
      .then(() => {
        console.log('V≈°echny tokeny smaz√°ny');
        // Odeber v≈°echny tokeny i lok√°lnƒõ
        document.querySelectorAll('.token').forEach(t => t.remove());
      })
      .catch(console.error);
  }
});


const drawCanvas = document.getElementById('drawLayer');
const ctx = drawCanvas.getContext('2d');

function resizeCanvas() {
  // Pou≈æij rozmƒõry p≈ô√≠mo z gridu, ne z containeru
  const rect = grid.getBoundingClientRect();
  drawCanvas.width = rect.width;
  drawCanvas.height = rect.height;
  
  // Nastav tak√© CSS rozmƒõry
  drawCanvas.style.width = rect.width + 'px';
  drawCanvas.style.height = rect.height + 'px';
  
  // P≈ôekresli v≈°echny tahy po resize
  db.ref('drawing').once('value', (snapshot) => {
    const strokes = snapshot.val() || {};
    Object.values(strokes).forEach(drawStroke);
  });
}

// Resize po vytvo≈ôen√≠ gridu
setTimeout(resizeCanvas, 100);

window.addEventListener('resize', () => {
  createGrid();
  setTimeout(resizeCanvas, 100);
});

let drawing = false;
let drawMode = false;
let currentStroke = [];
let drawingHistory = []; // Pro sledov√°n√≠ po≈ôad√≠ kreseb

ctx.lineCap = 'round';
ctx.lineJoin = 'round';

const drawColorInput = document.getElementById('drawColor');
const toggleDrawBtn = document.getElementById('toggleDraw');
const undoDrawBtn = document.getElementById('undoDraw');
const clearCanvasBtn = document.getElementById('clearCanvas');
const brushWidthInput = document.getElementById('brushWidth');
const brushWidthValue = document.getElementById('brushWidthValue');

brushWidthInput.addEventListener('input', (e) => {
  brushWidthValue.textContent = e.target.value;
});

toggleDrawBtn.addEventListener('click', () => {
  drawMode = !drawMode;
  drawCanvas.style.pointerEvents = drawMode ? 'auto' : 'none';
  tokensContainer.style.pointerEvents = drawMode ? 'none' : 'auto';
  document.querySelectorAll('.token').forEach(t => {
    t.style.pointerEvents = drawMode ? 'none' : 'auto';
  });
  toggleDrawBtn.textContent = drawMode ? 'Vypnout kreslen√≠' : 'Re≈æim kreslen√≠';
});

undoDrawBtn.addEventListener('click', () => {
  if (drawingHistory.length === 0) return;
  
  // Odeber posledn√≠ timestamp z historie
  const lastTimestamp = drawingHistory.pop();
  
  // Sma≈æ z Firebase
  db.ref('drawing/' + lastTimestamp).remove();
  
  // P≈ôekresli canvas bez posledn√≠ kresby
  ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
  db.ref('drawing').once('value', (snapshot) => {
    const strokes = snapshot.val() || {};
    Object.values(strokes).forEach(drawStroke);
  });
});

clearCanvasBtn.addEventListener('click', () => {
  ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
  db.ref('drawing').set(null);
  drawingHistory = [];
});

function drawStroke(stroke) {
  if (stroke.points.length < 2) return;
  ctx.strokeStyle = stroke.color;
  ctx.lineWidth = stroke.width;
  ctx.beginPath();
  
  // Pou≈æij quadratic curves pro hlad≈°√≠ k≈ôivky
  ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
  
  for (let i = 1; i < stroke.points.length - 1; i++) {
    const xc = (stroke.points[i].x + stroke.points[i + 1].x) / 2;
    const yc = (stroke.points[i].y + stroke.points[i + 1].y) / 2;
    ctx.quadraticCurveTo(stroke.points[i].x, stroke.points[i].y, xc, yc);
  }
  
  // Posledni bod
  if (stroke.points.length > 1) {
    const lastPoint = stroke.points[stroke.points.length - 1];
    ctx.lineTo(lastPoint.x, lastPoint.y);
  }
  
  ctx.stroke();
}

drawCanvas.addEventListener('mousedown', (e) => {
  if (!drawMode) return;
  drawing = true;
  const rect = drawCanvas.getBoundingClientRect();
  currentStroke = {
    color: drawColorInput.value,
    width: parseInt(brushWidthInput.value),
    points: [{ x: e.clientX - rect.left, y: e.clientY - rect.top }]
  };
});

drawCanvas.addEventListener('mousemove', (e) => {
  if (!drawMode || !drawing) return;
  const rect = drawCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  currentStroke.points.push({ x, y });
  
  // Vykresluj pr≈Øbƒõ≈ænƒõ bƒõhem tahu
  ctx.strokeStyle = currentStroke.color;
  ctx.lineWidth = currentStroke.width;
  
  if (currentStroke.points.length === 2) {
    ctx.beginPath();
    ctx.moveTo(currentStroke.points[0].x, currentStroke.points[0].y);
  }
  
  if (currentStroke.points.length > 1) {
    const prevPoint = currentStroke.points[currentStroke.points.length - 2];
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
  }
});

drawCanvas.addEventListener('mouseup', () => {
  if (!drawing) return;
  drawing = false;
  if (currentStroke.points.length > 1) {
    const timestamp = Date.now();
    db.ref('drawing/' + timestamp).set(currentStroke);
    drawingHistory.push(timestamp);
  }
});

drawCanvas.addEventListener('mouseleave', () => {
  if (drawing) {
    drawing = false;
  }
});

function getTouchPos(touchEvent) {
  const rect = drawCanvas.getBoundingClientRect();
  const t = touchEvent.touches[0] || touchEvent.changedTouches[0];
  return {
    x: t.clientX - rect.left,
    y: t.clientY - rect.top
  };
}

drawCanvas.addEventListener('touchstart', (e) => {
  if (!drawMode) return;
  e.preventDefault();
  const pos = getTouchPos(e);
  drawing = true;
  currentStroke = {
    color: drawColorInput.value,
    width: parseInt(brushWidthInput.value),
    points: [pos]
  };
});

drawCanvas.addEventListener('touchmove', (e) => {
  if (!drawMode || !drawing) return;
  e.preventDefault();
  const pos = getTouchPos(e);
  currentStroke.points.push(pos);
  
  // Vykresluj pr≈Øbƒõ≈ænƒõ bƒõhem tahu
  ctx.strokeStyle = currentStroke.color;
  ctx.lineWidth = currentStroke.width;
  
  if (currentStroke.points.length === 2) {
    ctx.beginPath();
    ctx.moveTo(currentStroke.points[0].x, currentStroke.points[0].y);
  }
  
  if (currentStroke.points.length > 1) {
    const prevPoint = currentStroke.points[currentStroke.points.length - 2];
    ctx.lineTo(pos.x, pos.y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
  }
});

drawCanvas.addEventListener('touchend', (e) => {
  if (!drawing) return;
  e.preventDefault();
  drawing = false;
  if (currentStroke.points.length > 1) {
    const timestamp = Date.now();
    db.ref('drawing/' + timestamp).set(currentStroke);
    drawingHistory.push(timestamp);
  }
});

function toggleCategory(header) {
  const content = header.nextElementSibling;
  const isOpen = content.style.display === 'flex';
  
  if (isOpen) {
    content.style.display = 'none';
    header.classList.remove('open');
  } else {
    content.style.display = 'flex';
    header.classList.add('open');
  }
}

  </script>
</body>
</html>
